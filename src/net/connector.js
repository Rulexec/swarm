var dgram = require('dgram');

var AsyncM = require('asyncm');

var crypto = require('./crypto');

module.exports = Connector;

let authKey = Buffer.from(
	'a7847ff672456c275807318f50dcd4e04696278a9531292826effa887ee9f987' +
	'86c2028ed0196701df48d1dee8e6a4635be700d9a3bb8d35b0a739d2a4455c38' +
	'aa29393e2af0151d716f14ca4dc115877fcdc01689cd89e0fc56dad72da8967a' +
	'88204ff1f56b952565796d906922222144a06b0eec897f500876f252f94f2b30' +
	'934329511ff513a03b4189e20914e080d6f5b6ab95b9c6169d53be808ecfa98e' +
	'6681e60e9dfe780cb00535b0c1a6a8ac1fe78391130cb7936d1e9c359b2a4744' +
	'9e127b3364cc25b5fa017fec6b27e6b9b14ff9eaae684e3743f9f374bc80c87e' +
	'e4443da1dbd180cc3a20dcad17cc4513585c1eaa7f4c7aecc8851931f814c681',

	'hex'
);

const CHUNKS_TIMEOUT = 3000;

function Connector(options) {
	var {port, onMessage} = options;

	var self = this;

	var socket;

	var queue = [],
	    isBound = false,
	    isErred = false;

	var bindWaiters = [];

	this.send = AsyncM.fun(function(onResult, onError, address, port, buffer) {
		if (isErred) { onError('erred'); return; }

		queue.push({address, port, buffer, onResult, onError});
		notifyQueue();
	});

	var isProcessingQueueSync = false;

	function notifyQueue() {
		if (!isBound && !isErred) return;
		if (!queue.length) return;

		if (isProcessingQueueSync) return;
		isProcessingQueueSync = true;

		while (true) {
			let item = queue.shift();

			if (isErred) {
				item.onError('erred');
				continue;
			}

			if (item.raw) {
				socket.send(item.buffer, item.port, port.address, function(error) {
					if (error) item.onError(error);
					else item.onResult();
				});
			} else {
				createPackets({
					item, authKey,
					authKeyId: 1,
				}).run(function(packets) {
					packets.forEach(function(packet) {
						queue.push(packet);
					});

					notifyQueue();
				}, function(error) {
					item.onError(error);
				});
			}

			break;
		}

		if (queue.length) setImmediate(notifyQueue);

		isProcessingQueueSync = false;
	}

	var messageClient = {
		reply: function(buffer) {
			return self.send(this.address, this.port, buffer);
		}
	};

	var pendingPackets = {};

	this.start = AsyncM.fun(function(onResult, onError) {
		if (socket) { onError('Already started'); return; }

		socket = dgram.createSocket('udp4');

		socket.on('error', function(error) {
			isErred = true;
			onError(error);
			socket.close();

			while (bindWaiters.length) bindWaiters.shift().onError(error);

			notifyQueue();
		});

		socket.on('message', function(buffer, info) {
			var address = info.address,
			    targetPort = info.port,
			    fullAddress = address + ':' + targetPort;

			readPacket({
				buffer: buffer,
				getAuthKey: function(keyId) {
					if (keyId === 1) return authKey;
					return null;
				}
			}).result(function(result) {
				function callOnMessage(buffer) {
					onMessage(Object.assign(Object.create(messageClient), {
						buffer: buffer,
						address: address,
						port: targetPort
					}));
				}

				if (result.chunksCount === 1) {
					callOnMessage(result.payload);
					return;
				}

				let key = result.packetId.toString('hex') + '-' + result.chunksCount + '-' + fullAddress;

				let pending = pendingPackets[key];
				if (!pending) {
					pending = {
						address: null,
						port: 0,
						chunks: new Array(result.chunksCount),
						chunksLeft: result.chunksCount,
						totalSize: 0,
						timeoutId: 0
					};
					pendingPackets[key] = pending;
				}

				let oldChunk = pending.chunks[result.chunkIndex],
				    isNewChunk = !oldChunk;

				if (oldChunk && !oldChunk.equals(result.payload)) {
					console.log('drop packet, not equals chunks', key);
					delete pendingPackets[key];
					return;
				}

				if (isNewChunk) {
					pending.chunks[result.chunkIndex] = result.payload;

					pending.chunksLeft--;
					pending.totalSize += result.payload.length;

					if (pending.timeoutId) clearTimeout(pending.timeoutId);

					if (!pending.chunksLeft) {
						let buffer = Buffer.allocUnsafe(pending.totalSize);

						let offset = 0;
						pending.chunks.forEach(function(chunk) {
							chunk.copy(buffer, offset);
							offset += chunk.length;
						});

						delete pending.chunks[result.chunkIndex];

						callOnMessage(buffer);
						return;
					}

					pending.timeoutId = setTimeout(function() {
						console.log('drop packet, timeout', key);
						delete pendingPackets[key];
					}, CHUNKS_TIMEOUT);
				}
			}).run()
		});

		socket.bind(port, function() {
			isBound = true;

			while (bindWaiters.length) bindWaiters.shift().onResult();

			notifyQueue();
		});
	});

	this.started = AsyncM.fun(function(onResult, onError) {
		if (isBound) { onResult(); return; }

		bindWaiters.push({onResult, onError});
	});

	this.getPort = function() {
		return socket.address().port;
	};
}

// Protocol

// Header:
//
//     version -- 1 byte, must be zero
//     key_id  -- 4 bytes, identifies used hardcoded auth_key
//     msg_key -- 16 bytes, generated by encryption schema
//
//     Encrypted:
//
//         id                 -- 8 bytes, must be random!
//         chunks total count -- 2 bytes
//         current chunk      -- 2 bytes
//         payload size       -- 2 bytes
//
// UDP safe payload size is 508 bytes
// Unecnrypted header is 21 byte, so, we have 487 bytes
// Encryption is done by 16-byte blocks, so, we have 480 bytes
// Encrypted header is 14 bytes, so, payload must be 466 bytes

var VERSION_OFFSET = 0,
    KEY_ID_OFFSET = 1,
    MSG_KEY_OFFSET = 5;
    MSG_KEY_SIZE = 16,
    ENCRYPTED_OFFSET = 21;

var CRYPT_ID_OFFSET = 0,
    CRYPT_ID_SIZE = 8,
    CRYPT_CHUNKS_COUNT_OFFSET = 8,
    CRYPT_CURRENT_CHUNK_OFFSET = 10,
    CRYPT_PAYLOAD_SIZE_OFFSET = 12,
    CRYPT_PAYLOAD_OFFSET = 14;

var PUBLIC_HEADER_SIZE = 21,
    CRYPT_HEADER_SIZE = CRYPT_PAYLOAD_OFFSET,
    PAYLOAD_SIZE = 466;

function createPackets(options) {
	var authKeyId = options.authKeyId,
	    authKey = options.authKey,
	    item = options.item,
	    data = item.buffer;

	var packets = [];

	var parallel = [];

	var chunksCount = Math.ceil(data.length / PAYLOAD_SIZE);

	var msgId = [0, 0];

	if (chunksCount > 1) {
		msgId[0] = (Math.random() * 0xffffffff) | 0;
		msgId[1] = (Math.random() * 0xffffffff) | 0;
	}

	let currentChunkIndex = 0;

	var chunksSent = 0;

	for (let offset = 0; offset < data.length; offset += PAYLOAD_SIZE) {
		let payloadSize = Math.min(PAYLOAD_SIZE, data.length - offset);

		let cryptSize = Math.ceil((CRYPT_HEADER_SIZE + payloadSize) / 16) * 16;

		let size = PUBLIC_HEADER_SIZE + cryptSize;

		let buffer = Buffer.allocUnsafe(size);

		buffer.writeUInt8(0, VERSION_OFFSET);
		buffer.writeUInt32BE(authKeyId, KEY_ID_OFFSET);

		let toEncrypt = buffer.slice(ENCRYPTED_OFFSET, ENCRYPTED_OFFSET + CRYPT_HEADER_SIZE + payloadSize);

		toEncrypt.writeInt32BE(msgId[0], CRYPT_ID_OFFSET);
		toEncrypt.writeInt32BE(msgId[1], CRYPT_ID_OFFSET + 4);

		toEncrypt.writeUInt16BE(chunksCount, CRYPT_CHUNKS_COUNT_OFFSET);
		toEncrypt.writeUInt16BE(currentChunkIndex, CRYPT_CURRENT_CHUNK_OFFSET);
		toEncrypt.writeUInt16BE(payloadSize, CRYPT_PAYLOAD_SIZE_OFFSET);

		data.copy(toEncrypt, CRYPT_PAYLOAD_OFFSET);

		parallel.push(crypto.encrypt(toEncrypt, {authKey}).result(function({buffer: encrypted, msgKey}) {
			msgKey.copy(buffer, MSG_KEY_OFFSET);
			encrypted.copy(buffer, ENCRYPTED_OFFSET);

			return Object.assign({}, item, {
				raw: true,
				buffer: buffer,

				onResult: function() {
					chunksSent++;

					if (chunksSent === chunksCount) item.onResult();
				}
			});
		}));

		currentChunkIndex++;
	}

	return AsyncM.parallel(parallel, { cancelRest: true });;
}

function readPacket(options) {
	var buffer = options.buffer,
	    getAuthKey = options.getAuthKey;

	if (buffer.length <= PUBLIC_HEADER_SIZE + CRYPT_HEADER_SIZE) {
		return AsyncM.error('too_small');
	}

	var version = buffer.readUInt8(VERSION_OFFSET);
	if (version !== 0) return AsyncM.error('unsupported version: ' + version);

	var keyId = buffer.readUInt32BE(KEY_ID_OFFSET),
	    authKey = getAuthKey(keyId);
	if (!authKey) return AsyncM.error('unsupported key: ' + keyId);

	var msgKey = buffer.slice(MSG_KEY_OFFSET, MSG_KEY_OFFSET + MSG_KEY_SIZE),
	    encrypted = buffer.slice(ENCRYPTED_OFFSET);

	return crypto.decrypt(encrypted, {authKey, msgKey}).result(function(buffer) {
		let packetId = buffer.slice(CRYPT_ID_OFFSET, CRYPT_ID_SIZE),
		    chunksCount = buffer.readUInt16BE(CRYPT_CHUNKS_COUNT_OFFSET),
		    chunkIndex = buffer.readUInt16BE(CRYPT_CURRENT_CHUNK_OFFSET),
		    payloadSize = buffer.readUInt16BE(CRYPT_PAYLOAD_SIZE_OFFSET),
		    payload = buffer.slice(CRYPT_PAYLOAD_OFFSET, CRYPT_PAYLOAD_OFFSET + payloadSize);

		if (chunkIndex >= chunksCount) return AsyncM.error('large_chunk_index');

		return AsyncM.result({packetId, chunksCount, chunkIndex, payloadSize, payload});
	});
}
